<!DOCTYPE html>
<html>
<head>
  <title>Ray Input: WebVR interaction patterns | Boris Smus</title>

  <meta charset='utf-8' />
  <meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0' />

  <meta name="description" content="What would the web look like if there were no scrollbars, no mouse cursors, and no clickable links? That's what VR is like today. On one hand, this is great! Developers are completely free to build however they want, leading to a lot of interesting experiments. On the other hand, it takes a lot of engineering effort to just get basic interactions up and running. Furthermore, it lacks consistency. The alluring promise of being able to navigate from world to world may be diluted by the frustration of having to rediscover new interaction paradigms every time.   While sane interaction defaults are badly needed, baking them into the platform violates principles of the  Extensible Web . With that in mind, I implemented a basic Ray-based interaction library called  RayInput , which provides reasonable defaults for interacting with 3D objects in and outside of VR. Here's what the interaction looks like on various platforms:" />
  <meta name="author" content="Boris Smus" />
  <link rel="canonical" href="https://smus.com/ray-input-webvr-interaction-patterns/" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Ray Input: WebVR interaction patterns" />
  <meta name="twitter:description" content="What would the web look like if there were no scrollbars, no mouse cursors, and no clickable links? That's what VR is like today. On one hand, this is great! Developers are completely free to build however they want, leading to a lot of interesting experiments. On the other hand, it takes a lot of engineering effort to just get basic interactions up and running. Furthermore, it lacks consistency. The alluring promise of being able to navigate from world to world may be diluted by the frustration of having to rediscover new interaction paradigms every time.   While sane interaction defaults are badly needed, baking them into the platform violates principles of the  Extensible Web . With that in mind, I implemented a basic Ray-based interaction library called  RayInput , which provides reasonable defaults for interacting with 3D objects in and outside of VR. Here's what the interaction looks like on various platforms:" />

  <!-- Facebook -->
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://smus.com/ray-input-webvr-interaction-patterns/" />
  <meta property="og:title" content="Ray Input: WebVR interaction patterns" />
  <meta property="og:description" content="What would the web look like if there were no scrollbars, no mouse cursors, and no clickable links? That's what VR is like today. On one hand, this is great! Developers are completely free to build however they want, leading to a lot of interesting experiments. On the other hand, it takes a lot of engineering effort to just get basic interactions up and running. Furthermore, it lacks consistency. The alluring promise of being able to navigate from world to world may be diluted by the frustration of having to rediscover new interaction paradigms every time.   While sane interaction defaults are badly needed, baking them into the platform violates principles of the  Extensible Web . With that in mind, I implemented a basic Ray-based interaction library called  RayInput , which provides reasonable defaults for interacting with 3D objects in and outside of VR. Here's what the interaction looks like on various platforms:" />

  <!-- Mastodon -->
  <link rel="me" href="https://mastodon.social/@borismus">

  <!-- Coil monetization experiment: https://coil.com/settings/monetize -->
  <meta name="monetization" content="$ilp.uphold.com/4Fnyw8KLaPZG">

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/static/icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/icons/favicon-16x16.png">
  <link rel="manifest" href="/static/icons/site.webmanifest">

  <!-- Styles -->
  <link
  href='//fonts.googleapis.com/css?family=Roboto+Condensed:300|Open+Sans+Condensed:700|Source+Serif+Pro:400,700|Inconsolata' rel='stylesheet' type='text/css'>
  <link rel='stylesheet' href='/static/css/style.css'>
  <link rel='stylesheet' href='/static/css/syntax-highlight.css'>

  <!-- Feed -->
  <link href="https://smus.com/atom.xml" rel="alternate" title="Boris Smus" type="application/atom+xml"/>
</head>
<body>
<header>
  <div id='title'>
    <h1><a href='/'>Boris Smus</a></h1>
    <h2>interaction engineering</h2>
  </div>
  <nav role='navigation'>
    <a href='/about/' >About</a>
    <a href='/blog/' >Blog</a>
    <a href='/projects/' >Projects</a>
  </nav>
</header>

<section id='main'>
  <article>
    <a href='/ray-input-webvr-interaction-patterns'><h1 class='title'>Ray Input: WebVR interaction patterns</h1></a>
    <div class='body'>
      <p>What would the web look like if there were no scrollbars, no mouse cursors, and
no clickable links? That's what VR is like today. On one hand, this is great!
Developers are completely free to build however they want, leading to a lot of
interesting experiments. On the other hand, it takes a lot of engineering effort
to just get basic interactions up and running. Furthermore, it lacks
consistency. The alluring promise of being able to navigate from world to world
may be diluted by the frustration of having to rediscover new interaction
paradigms every time.</p>
<p>While sane interaction defaults are badly needed, baking them into the platform
violates principles of the <a href="https://github.com/extensibleweb/manifesto">Extensible Web</a>. With that in mind, I
implemented a basic Ray-based interaction library called <a href="https://github.com/borismus/ray-input">RayInput</a>, which
provides reasonable defaults for interacting with 3D objects in and outside of
VR. Here's what the interaction looks like on various platforms:</p>
<iframe width="600" height="340" src="//www.youtube.com/embed/gjj2XQYC998" frameborder="0" allowfullscreen></iframe>

<!--more-->

<h2>What does Ray Input actually do?</h2>
<p>Ray Input aims to provide reasonable interaction defaults, relying on the
hardware available for each platform:</p>
<ul>
<li>On desktop, look around by dragging, interact by clicking.</li>
<li>On mobile, look around via magic window or touch pan, interact by tapping.</li>
<li>In VR, interaction depends on a reticle or on a ray.<ul>
<li>If there is no controller (eg. Cardboard), use a gaze based reticle to
  interact with objects.</li>
<li>If there is a 3DOF controller (eg. Daydream), apply an arm model and
  interact with objects using a ray emanating from the controller.</li>
<li>If there is a 6DOF controller, interact with objects using the ray.</li>
</ul>
</li>
</ul>
<p>Of course, you may want to customize your interactions on a per-platform basis.
For example, if you are developing an application primarily for the Vive, you
may want to take advantage of the specific richness that a Vive controller
provides. Ray Input is not meant to be prescriptive, merely to provide
reasonable defaults.</p>
<h2>API</h2>
<p>The library's API is documented on the <a href="https://github.com/borismus/ray-input">github page</a>, and I also provide a
<a href="https://borismus.github.io/ray-input">simple example that uses Ray Input</a> to pick items from a 2D menu.</p>
<h2>Arm models for orientation-only controllers</h2>
<p>If a VR controller is present, Ray Input defaults to using a ray-based input
method, which behaves much like a laser pointer.</p>
<p>The Daydream View controller is not position tracked. The only pose information
it provides is the orientation, which is in the same coordinate system as the
head. Where should we position such orientation-only (3DOF) controllers? In
particular, where should the ray come from? Having it emanate from the stomach
or head, like the arm of an exotic god, would be very unnatural. So we need to
be slightly more clever.</p>
<p>Enter the arm model, which, given a controller orientation, spits out a
plausible controller position. Obviously the position it provides is only a
reasonable guess, and may not correspond to the controller's actual position.
But it sure is a lot better than nothing. This sort of problem is common in
graphics and robotics, and can be solved with inverse kinematics.</p>
<p>In this case, we follow a simpler approach. Most of the <a href="https://github.com/borismus/ray-input/blob/master/src/orientation-arm-model.js">code to do
this</a> is lifted from a native implementation of Daydream arm model.
To debug it, I built a very rough simulator, which lets you specify the
orientation of a virtual head and hand, run it through the model, and visualize
the resulting pose of the controller:</p>
<p><a href="https://borismus.github.io/ray-input/daydream-simulator.html"><img alt="Daydream arm model simulator" src="arm-model.png" /></a></p>
<p>As always, very open to feedback, bug reports, and pull requests via
<a href="https://github.com/borismus/ray-input">github</a>.</p>
    </div>
    <div class='subfooter'>
      <div class='tombstone'>▪</div>
      <time class='published'>October 11, 2016</time>
    </div>
  </article>
</section>


<footer>
  <div>
    © Copyright 2005–2023 Boris Smus.
  </div>
  <nav role="footer">
    <a href='https://smus.com/atom.xml'>RSS</a>
  </nav>
</footer>

<!-- Misc scripts: syntax highlighting, analytics, stats. -->
<script src="/static/js/highlight.pack.js"></script>
<!-- Syntax highlighting for code. -->
<script>
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
</script>
<!-- Lightning builder error check. -->
<script src="/lightning_error.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-38Y45XD5VQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-38Y45XD5VQ');
</script>


</body>
</html>